# -*- coding: utf-8 -*-
"""Analyzing_trading_cost.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V-Pg-X2g8ZbcjC_0i4BgMDwZ0SiHgQLJ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

import warnings
warnings.filterwarnings('ignore')

from google.colab import drive
drive.mount('/gdrive')

msft_trades = pd.read_csv('/gdrive/MyDrive/MMS/transactionCost /MSFT_Trades.csv', encoding='latin-1')
msft_quotes = pd.read_csv('/gdrive/MyDrive/MMS/transactionCost /MSFT_Quotes.csv', encoding='latin-1')
f_trades = pd.read_csv('/gdrive/MyDrive/MMS/transactionCost /F_Trades.csv', encoding='latin-1')
f_quotes = pd.read_csv('/gdrive/MyDrive/MMS/transactionCost /F_Quotes.csv', encoding='latin-1')
jpm_trades = pd.read_csv('/gdrive/MyDrive/MMS/transactionCost /JPM_Trades.csv', encoding='latin-1')
jpm_quotes = pd.read_csv('/gdrive/MyDrive/MMS/transactionCost /JPM_Quotes.csv', encoding='latin-1')

msft_quotes

def summary(df):
  summary = df.describe()
  check_missingness = df.isna().sum()
  return summary, pd.DataFrame(check_missingness, columns=['missing values'])

"""We randomly sample a subset of stocks. This sample of stocks will be our order, and we will evaluate our order based on quoted spreads, effective spreads, realized spreads, and implementation shortfall. We will always assume that our random order is an order to buy stock."""

from pandas.core.common import random_state
def quoted_spread(traded, quoted, n, samp):
  if samp == True:
    first_day = traded['Date'] == 20210115
    first_day = traded[first_day]
    sample = first_day.sample(n=n)
  else:
    sample = traded.sample(n=n, replace=True)
  sample.sort_values(by ='time_SIP',inplace = True)
  quoted.sort_values(by ='time_SIP',inplace = True)
  result = pd.merge_asof(sample, quoted, on='time_SIP', by='Date', direction='forward')
  result['quotesSpread'] = result['BEST_ASK'] - result['BEST_BID']
  quoted1 = quoted.copy(deep=True)
  quoted1['time_SIP'] = quoted1['time_SIP']-30   #we are taking the lag time of 30 sec
  quoted1['mid_quotes_30sec'] = (quoted1['BEST_ASK'] + quoted1['BEST_BID'])/2 #this gives the mid_quotes  30 sec
  quoted1 = quoted1[["time_SIP", "Date", "mid_quotes_30sec"]]
  result.sort_values(by ='time_SIP',inplace = True)
  quoted1.sort_values(by ='time_SIP',inplace = True)
  quoted_traded = pd.merge_asof(result,
          quoted1,
          on = 'time_SIP',
          by='Date',
          direction = 'nearest')
  return quoted_traded.dropna()

quoted_spread(msft_trades, msft_quotes, 5000, True)

quoted_spread(msft_trades, msft_quotes, 10000, False)

"""


### Step 2: Calculate average quoted spreads.
To do this, we must match our sample of trades with the quotes
Note that we we match each trade with the closest trade *before* it."""

def average_quoted_spread(result):

  '''
  calculates the average spreads
  '''
  total_size = sum(result['PRICE'] * result['SIZE'])
  result['quotesSpread'] = result['BEST_ASK'] - result['BEST_BID']
  total_quotes_spreads = sum(result['quotesSpread'] * result['SIZE'])
  total_quotes_spreads_bp = total_quotes_spreads / total_size *10000
  return round(total_quotes_spreads_bp,4)

'''

total_size = for all the price columns * all size column(or the quantities) and takes the total sum of these two columns.

result['quotesSpread'] = creats a column named 'quotesSpread' in the result dataFrame which stores spreads(ask - bid)

total_quotes_spreads = for all the quotes_spread columns * all size column(or the quantities) and takes the total sum of these two columns

total_quotes_spreads_bp = this objects gives the average quotes spreads
  '''

"""assume that we are always sending buy orders.

"""

def effective_spread(result):
  total_size = sum(result['PRICE'] * result['SIZE'])
  result['effective_spread'] = 2*(abs(result['PRICE'] - ((result['BEST_ASK'] + result['BEST_BID'])/2)))
  total_quoted_spreads = sum(result['effective_spread'] * result['SIZE'])
  total_quoted_spreads_BP = total_quoted_spreads/total_size *10000
  return round(total_quoted_spreads_BP,4)
  '''
  effective_spread : in order to calaculate the effective spread " 2*| price -(ask-bid)/2) | " formula from the christie and huang article
  '''

def realized_spreads(result):
  total_size = sum(result['PRICE'] * result['SIZE'])
  result['realized_spread'] = result['PRICE'] - result['mid_quotes_30sec']
  total_quoted_spreads = sum(result['realized_spread'] * result['SIZE'])
  total_quoted_spreads_BP = (total_quoted_spreads / total_size) * 10000
  return round(total_quoted_spreads_BP,4)

"""For the calculation of IS, use the very first child order as the "decision price"
"""

def implementation_shortfall(result):
  start_order_day = result['Date'].min()
  first_order_time = result[result['Date']==start_order_day]['time_SIP'].min()
  first_price = result[result['time_SIP']==first_order_time]['PRICE']
  benchmark = int(first_price)
  total_size = sum(result['PRICE'] * result['SIZE'])
  result['imp_shortfall'] = (result['PRICE'] - benchmark) / benchmark
  total_imp_shortfall = sum(result['imp_shortfall'] * result['SIZE'])
  imp_shortfall_BP = (total_imp_shortfall / total_size) * 10000
  return round(imp_shortfall_BP,4)

def implementation_shortfall_closing_price(result):
  start_order_day = result['Date'].max()
  first_order_time = result[result['Date']==start_order_day]['time_SIP'].max()
  first_price = result[result['time_SIP']==first_order_time]['PRICE']
  benchmark = int(first_price)
  total_size = sum(result['PRICE'] * result['SIZE'])
  result['imp_shortfall'] = (result['PRICE'] - benchmark) / benchmark
  total_imp_shortfall = sum(result['imp_shortfall'] * result['SIZE'])
  imp_shortfall_BP = (total_imp_shortfall / total_size) * 10000
  return round(imp_shortfall_BP,4)

"""### Final spreads table"""

def final_df(result):
  start_order_day = result['Date'].min()
  first_order_time = result[result['Date']==start_order_day]['time_SIP'].min()
  first_price = result[result['time_SIP']==first_order_time]['PRICE']
  benchmark = int(first_price)
  total_size = sum(result['PRICE'] * result['SIZE'])
  result['imp_shortfall'] = (result['PRICE'] - benchmark) / benchmark
  return result

final_df(quoted_spread(msft_trades, msft_quotes, 5000, True))

final_df(quoted_spread(msft_trades, msft_quotes, 5000, False))

"""### Analysis:"""

summary(quoted_spread(jpm_trades, jpm_quotes, 5000, True))

"""### First_day Sample (all result in bps):"""

def caller(trade, quotes, n):
  average_quoted_spreads = average_quoted_spread(quoted_spread(trade, quotes, n, True))
  average_effective_spreads = effective_spread(quoted_spread(trade, quotes, n, True))
  average_realized_spread = realized_spreads(quoted_spread(trade, quotes, n, True))
  average_imp_spread  = implementation_shortfall(quoted_spread(trade, quotes, n, True))
  Average_imp_spread_close = implementation_shortfall_closing_price(quoted_spread(trade, quotes, n, True))
  data = pd.DataFrame([average_quoted_spreads, average_effective_spreads, average_realized_spread, average_imp_spread, Average_imp_spread_close],
                      index=['quoted','effective','realized','imp_short_start (bps)', 'imp_short_close (bps)'])

  return data

msft_2000 = caller(msft_trades, msft_quotes, 2000)
msft_5000 = caller(msft_trades, msft_quotes, 5000)
msft_10000 = caller(msft_trades, msft_quotes, 10000)
msft = pd.concat([msft_2000, msft_5000, msft_10000],axis=1)

f_2000 = caller(f_trades, f_quotes, 2000)
f_5000 = caller(f_trades, f_quotes, 5000)
f_10000 = caller(f_trades, f_quotes, 10000)
f = pd.concat([f_2000, f_5000, f_10000],axis=1)

jpm_1000 = caller(jpm_trades, jpm_quotes, 1000)
jpm_1500 = caller(jpm_trades, jpm_quotes, 1500)
jpm_2000 = caller(jpm_trades, jpm_quotes,2000)
jpm = pd.concat([jpm_1000, jpm_1500, jpm_2000],axis=1)

first_day_sample = pd.concat([msft, f, jpm], axis=1)
first_day_sample.columns =['msft_2000','msft_5000','msft_10000',
                           'f_2000', 'f_5000','f_10000',
                           'jpm_1000','jpm_1500', 'jpm_2000']

first_day_sample

"""### traded Sample (all results in bps):"""

def traded_caller(trade, quotes, n):
  average_quoted_spreads = average_quoted_spread(quoted_spread(trade, quotes, n, False))
  average_effective_spreads = effective_spread(quoted_spread(trade, quotes, n, False))
  average_realized_spread = realized_spreads(quoted_spread(trade, quotes, n, False))
  average_imp_spread  = implementation_shortfall(quoted_spread(trade, quotes, n, False))
  Average_imp_spread_close = implementation_shortfall_closing_price(quoted_spread(trade, quotes, n, False))
  traded_data = pd.DataFrame([average_quoted_spreads, average_effective_spreads, average_realized_spread, average_imp_spread, Average_imp_spread_close],
                      index=['quoted','effective','realized','imp_short_start (bps)', 'imp_short_close (bps)'])

  return traded_data

msft_2000 = traded_caller(msft_trades, msft_quotes, 2000)
msft_5000 = traded_caller(msft_trades, msft_quotes, 5000)
msft_6000 = traded_caller(msft_trades, msft_quotes, 10000)
msft = pd.concat([msft_2000, msft_5000, msft_6000],axis=1)

f_2000 = traded_caller(f_trades, f_quotes, 2000)
f_5000 = traded_caller(f_trades, f_quotes, 5000)
f_10000 = traded_caller(f_trades, f_quotes, 10000)
f = pd.concat([f_2000, f_5000, f_10000],axis=1)

jpm_1000 = traded_caller(jpm_trades, jpm_quotes, 1000)
jpm_1500 = traded_caller(jpm_trades, jpm_quotes, 1500)
jpm_2000 = traded_caller(jpm_trades, jpm_quotes, 2000)
jpm = pd.concat([jpm_1000, jpm_1500, jpm_2000,],axis=1)


traded_day_sample = pd.concat([msft, f, jpm], axis=1)
traded_day_sample.columns =['msft_2000','msft_5000','msft_10000',
                           'f_2000', 'f_5000','f_10000',
                           'jpm_1000','jpm_1500', 'jpm_2000']

traded_day_sample